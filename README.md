# Практическая работа №1 по предмету "Численное моделирование"

Вариант 8: $LL^t$ разложение, матрицы хранятся в разреженном профильном формате.

## Оглавление:

- [Практическая работа №1 по предмету "Численное моделирование"](#практическая-работа-1-по-предмету-численное-моделирование)
  - [Оглавление:](#оглавление)
  - [1. Основная программа](#1-основная-программа)
  - [2. Генератор матриц Гильберта](#2-генератор-матриц-гильберта)
  - [3. Быстрый прогон матриц Гильберта](#3-быстрый-прогон-матриц-гильберта)
  - [4. Решатель СЛАУ методом Гаусса](#4-решатель-слау-методом-гаусса)
  - [5. Небольшой экскурс по теории в целом](#5-небольшой-экскурс-по-теории-в-целом)
    - [5.1 Зачем нужны разреженные форматы хранения?](#51-зачем-нужны-разреженные-форматы-хранения)
    - [5.2 Зачем нужны другие методы решения матриц, если есть метод Гаусса?](#52-зачем-нужны-другие-методы-решения-матриц-если-есть-метод-гаусса)
    - [5.3 Где какой метод эффективнее использовать?](#53-где-какой-метод-эффективнее-использовать)

---

## 1. Основная программа

Основная программа находится в подкаталоге "chm_o1" (не спрашивайте почему так, сам не знаю). Выделение памяти происходит до начала всех вычислений в коде. 

Используемый тип данных определяется через `#define` в самом начале модуля main.cpp. Есть 3 предопределения:

1. `__ALL_FLOAT__` - для всех чисел используется одинарная точность;
2. `__SEMI_FLOAT__` - для накопителей (переменные, накапливающие в себе суммы в циклах) используется двойная точность, для всего остального всё так же одинарная. Так же такую точность называют как "двойная точность для скалярных произведений" (поскольку накапливает в себе результат скалярных произведений);
3. `__ALL_DOUBLE__` - значение по умолчанию - для всех чисел используется двойная точность.

Помимо точности, дефайны влияют так же на количество знаков выводимых в консоль чисел (7 значащих знаков для float и 14 для double), на окрестность сравнения чисел с нулём (для исключения случаев деления на ноль), а так же на названия выходных файлов (каждая выбранная точность имеет свой файл).

Маленькая колхозная `DotsToCommas` в модуле `main.cpp` нужна для перевода всех точек в запятые для удобного экспорта чисел в таблицы excel.

В случае ошибок, функции модуля матрицы должны выдавать исключения, которые отлавливаются в функции `main`.

## 2. Генератор матриц Гильберта

Генератор матриц Гильберта находится в подкаталоге "hilbert_gen" и представлен единым модулем `main.cpp`. Возможны два варианта запуска скомпилированного модуля:

1. С передачей размера матрицы Гильберта в качестве параметра консоли
2. С заданием размера матрицы после запуска через консольный ввод (если параметр размера матрицы не был передан через консольный параметр)

Матрицы гильберта генерируются в программе в плотном формате (поскольку и сами по себе они являются плотными), а затем выводятся в файлы в требуемом для $LL^t$ разложения разреженном формате.

В качестве точного вектора $x$ используется стандартный вектор $(1, 2, 3, 4, \dots)$. 

## 3. Быстрый прогон матриц Гильберта

Для быстрого прогона матриц Гильберта размерности от 1 до k, в подкаталоге "Hilbert" существует простенький powershell-скрипт "generator.ps1". При его запуске обязательно необходимо передать в качестве параметра командной строки число k. Так же, в эту директорию необходимо поместить следующие исполняемые файлы:

* "hilbert_gen.exe" - скопмилированная программа генератора матриц Гильберта;
* "float_solver.exe" - скомпилированная основная программа для float-точности (после компиляции необходимо переименовать исполняемый файл)
* "scalar_solver.exe" - аналогично для `__SEMI_FLOAT__` точности;
* "double_solver.exe" - аналогично для `__ALL_DOUBLE__` точности.

На выходе получится набор директорий по названию размера матрицы Гильберта, содержащие в себе результаты решения для всех точностей.

## 4. Решатель СЛАУ методом Гаусса

Для решений СЛАУ методом Гаусса (для сравнения с методом $LL^t$) был написан соответствующий модуль, находящийся в подкаталоге "gauss_solver" в модуле "main.cpp". Никаких различий в плане работы с этим модулем, по сравнению с модулем для метода $LL^t$, быть не должно.

Основное отличие - метод Гаусса умеет решать в том числе и нессиметричные матрицы, и плохо обусловленные.

Для простоты исследований, метод Гаусса был реализован для плотных матриц, поэтому при входных данных в виде разреженной матрицы, он при считывании самостоятельно заполняет её как плотную матрицу.

---

## 5. Небольшой экскурс по теории в целом

### 5.1 Зачем нужны разреженные форматы хранения?

Вопрос банален, ответ анал...огичен - чтобы экономить память. Во время вычислений всяких там физико-математических задач, частенько матрицы будут достаточно большой размерности, но при этом в них будет не очень много элементов. Поэтому на курсе ЧМ нас будут учить как раз-таки работать с подобного вида матрицами эффективней - это не только сэкономит нам количество затрачиваемой памяти, но ещё и ускорит работу программы, так как ей не придётся проходить по лишним нулям.

### 5.2 Зачем нужны другие методы решения матриц, если есть метод Гаусса?

На самом деле метод Гаусса - достаточно универсальный метод, который можно применять в довольно широком спектре задач. Но есть такие задачи, в которых метод Гаусса оказывается не очень эффективным. И тогда ему на помощь приходят другие **прямые методы решения СЛАУ**, например, $LU$ или $LL^t$.

Если посчитать по количеству операций, то эти методы в среднем будут значительно опережать метод Гаусса на больших размерностях матриц. Для примера, количество действий для метода Гаусса:

$$\frac{2}{3}N^3+\frac{5}{2}N^2+\frac{1}{6}N \text{,}$$

И количество действий для метода $LL^t$:

$$\frac{1}{3}N^3+\frac{5}{2}N^2-\frac{13}{6}N \text{.}$$

Таким образом, видим, что метод $LL^t$ на больших матрицах оказывается в 2 раза быстрее, чем метод Гаусса.

### 5.3 Где какой метод эффективнее использовать?

Перед этим необходимо рассказать об обусловленности матрицы.

**Число обусловленности матрицы** - это отношение наибольшего собственного значения данной матрицы к наименьшему:

$$Condition(A) = \frac{max(\lambda_i)}{min(\lambda_i)}$$

На что оно влияет?

Допустим, есть у нас система $A\tilde{x} = \tilde{b}$, где $\tilde{x}, \tilde{b}$ - точные значения решения системы. И допустим, у нас есть её приблизительное решение $Ax = b$. Тогда мы можем посчитать погрешность решения $\Delta x = x - \tilde{x}$ и невязку решения $\Delta b = b - \tilde{b}$.

Правило таково: чем **больше** обусловленность матрицы $A$, тем **сильнее** меняется невязка решения при небольшом изменении погрешности решения.

Различают плохо обусловленные (с большим числом обусловленности) и хорошо обусловленные (с малым числом обусловленности) матрицы.

Ну а теперь можно перейти к ситуациям наибольшей эффективности методов:

Метод $LL^t$ наиболее эффективен, если:
- Матрица $A$ хорошо обусловлена;
- Матрица $A$ имеет большие размеры;
- Матрица $A$ симметричная (без симметрии матрицы метод работать не будет).

В противных же случаях, метод Гаусса чаще будет оказываться лучше метода $LL^t$.